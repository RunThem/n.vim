## Main
# main
snippet main
	int main(int argc, const char* argv[]) {
		${0}

		return 0;
	}

# main(void)
snippet mainn
	int main(void) {
		${0}

		return 0;
	}

## Preprocessor
# #include <...>
snippet inc
	#include <${1:stdio}.h>

# #include "..."
snippet Inc
	#include "${1}"

# ifndef...define...endif
snippet ndef
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	$0
	#endif /* !$1 */

# define
snippet def
	#define ${1}

# ifdef...endif
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif /* $1 */

# if
snippet #if
	#if ${1:FOO}
		${0:${VISUAL}}
	#endif /* $1 */

# header include guard
snippet once
	#ifndef ${1:`!lua string.upper(string.gsub(vim.fn.expand('%'), '%.', '_'))`}
	#define $1

	${0}

	#endif /* end of include guard: $1 */

# Disable C++ name mangling in C headers
snippet nocxx
	#ifdef __cplusplus
	extern "C" {
	#endif

	${0}

	#ifdef __cplusplus
	} /* extern "C" */
	#endif

## Control Statements
# if
snippet if
	if (${1:true}) {
		${0:${VISUAL}}
	}

# if ... else
snippet ife
	if (${1:true}) {
		${2:${VISUAL}}
	} else {
		${0}
	}

# else
snippet el
	else {
		${0:${VISUAL}}
	}

# else if
snippet elif
	else if (${1:true}) {
		${0:${VISUAL}}
	}

# switch
snippet switch
	switch (${1:/* variable */}) {
		default:
			${2}
	}

# case
snippet case
	case ${1:/* variable case */}:
		${2}
  breal;

snippet ret
	return ${0};

snippet ex
	exit($0);

## Loops
# for
snippet for
	for (${1}) {
		$0
	}

# while
snippet wh
	while (${1}) {
		${0:${VISUAL}}
	}

# do... while
snippet do
	do {
		${0:${VISUAL}}
	} while ($1);

## Functions
# function definition
snippet fun
	${1:void} ${2:function_name}(${3}) {
		${4}
	}

# function definition with Doxygen documentation
snippet dfun
	/*!
   * \brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * \return ${3:Return parameter description}
	 */
	${4:void} ${5:function_name}() {
		${6}
	}

# function declaration
snippet fund
	${1:void} ${2:function_name}(${3});

## Types
# typedef
snippet td
	typedef ${1:int} ${2:MyCustomType};

# struct
snippet st
	/*!
   * \struct $1
	 * \brief ${3:Brief struct description}
	 *
	 * ${4:Detailed description}
	 */
	struct ${1} {
		${2:Data} /*!< ${4:Description} */
	}${5: /* optional variable list */};

# typedef struct
snippet tds
	/*!
   * \struct $2
	 * \brief ${5:Brief struct description}
	 *
	 * ${6:Detailed description}
	 */
	typedef struct ${2:_$1 }{
		m_${3:Data} /*!< ${4:Description} */
	} ${1:`vim_snippets#Filename('$1_t', 'name')`};

snippet enum
	/*!
   * \enum $1
	 *
	 * ${2:Detailed description}
	 */
	enum ${1:name} { ${0} };

# typedef enum
snippet tde
	/*!
   * \enum $2
	 *
	 * ${4:Detailed description}
	 */
	typedef enum {
		${1:Data} /*!< ${3:Description} */
	} ${2:foo};

## Input/Output
# printf
snippet pr
	printf("${1:%s}\n"${2});

# fprintf (again, this isn't as nice as TextMate's version, but it works)
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});

snippet prd
	printf("${1:} = %d\n", $1);

snippet prf
	printf("${1:} = %f\n", $1);

snippet prx
	printf("${1:} = %${2}\n", $1);

## Assertions
snippet as
	assert($1);

snippet asl
	assert(${1:ptr} != NULL);

## Dynamic Allocation
snippet mlc
	${1:ptr} = (${2:type}*) malloc(sizeof($2));

snippet clc
	${1:ptr} = (${2:type}*) calloc(${3:size}, sizeof($2));

snippet rlc
	${1:ptr} = realloc($1, ${2:size} * sizeof(${3:type}));

snippet mlcd
	${1:type} ${2:ptr} = ($1*) malloc(sizeof($1));

snippet clcd
	${1:type} ${2:ptr} = ($1*) calloc(${3:size}, sizeof($1));

snippet fre
	free(${1:ptr});

##
# TODO section
snippet todo
	/*!
   * TODO: ${1:Todo description here}
	 * \todo $1
	 */
	 
## Miscellaneous
# This is kind of convenient
snippet .
	[${1}]

snippet asm
	__asm__ __volatile__(
	"${0}\n\t"
	:
	:
	);
